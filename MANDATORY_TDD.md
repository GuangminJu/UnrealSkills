# 强制性TDD工作流程 - 不可违反的规则

## ⚠️ CRITICAL - 这是强制性要求，不是建议

当用户要求实现任何C++代码功能时，Claude **必须**按照以下顺序执行，**不允许跳过任何步骤**：

## 强制执行顺序（不可更改）

### 1. 立即声明使用TDD
在开始任何实现之前，**必须**明确告诉用户：
```
"我将使用TDD方式实现这个功能：
1. 先编写测试用例
2. 验证测试失败（红）
3. 实现功能
4. 构建项目
5. 运行测试验证（绿）"
```

### 2. 设计并编写测试（第一步）
**在编写任何功能代码之前**，必须：
- 创建测试文件（如果不存在）
- 编写至少3-5个测试用例，覆盖：
  - 正常路径（happy path）
  - 边界条件（edge cases）
  - 错误处理（error handling）
  - 空值/nullptr处理
  - 无效输入

### 3. 验证测试失败（红阶段）
**必须**执行：
1. 使用 `/ue-build` 或 Skill tool with skill="ue-build" 编译项目
2. 使用 `/ue-test` 或 Skill tool with skill="ue-test" 运行新编写的测试
3. **确认测试失败** - 这证明测试是有效的
4. 如果测试意外通过，说明测试写错了，需要修正

### 4. 实现功能代码
只有在测试失败后，才能开始实现功能：
- 编写最小化的代码使测试通过
- 遵循UE编码规范
- 添加必要的包含和依赖

### 5. 构建项目（自动执行）
**不等用户要求**，自动执行：
```
使用 Skill tool with skill="ue-build"
```
如果构建失败：
- 分析错误
- 修复代码
- 重新构建
- 重复直到构建成功

### 6. 运行测试验证（绿阶段）
构建成功后，**立即自动执行**：
```
使用 Skill tool with skill="ue-test" 运行相关测试
```
如果测试失败：
- 分析失败原因
- 修复实现代码
- 重新构建
- 重新测试
- 重复直到所有测试通过

### 7. 运行完整测试套件（回归检查）
**必须**运行项目的所有相关测试，确保：
- 新功能没有破坏现有功能
- 没有引入回归问题

### 8. 最终报告
只有在所有测试通过后，才能报告完成：
```
"✅ 功能实现完成并通过测试

实现：
- [功能列表]

测试：
- ✅ [测试1名称] - 通过
- ✅ [测试2名称] - 通过
- ✅ [测试3名称] - 通过
...

构建时间：X秒
测试时间：Y秒
总测试数：N个，全部通过"
```

## ❌ 禁止的行为

以下行为是**严格禁止**的：

1. ❌ **先实现功能，后写测试** - 违反TDD原则
2. ❌ **实现功能后不写测试** - 不可接受
3. ❌ **编译成功后不运行测试** - 必须验证
4. ❌ **等待用户要求才进行测试** - 必须主动
5. ❌ **说"功能完成"但没运行测试** - 欺骗性
6. ❌ **跳过"红-绿"循环** - 违反TDD核心
7. ❌ **测试失败但声称完成** - 不诚实

## 强制检查清单

在标记任务完成前，Claude必须自查：

- [ ] 是否先写了测试？
- [ ] 测试是否先失败了（红）？
- [ ] 是否实现了功能？
- [ ] 是否自动执行了构建（不等用户要求）？
- [ ] 是否自动执行了测试（不等用户要求）？
- [ ] 所有新测试是否都通过了（绿）？
- [ ] 是否运行了回归测试？
- [ ] 是否向用户报告了完整的测试结果？

**如果任何一项是"否"，任务就不算完成。**

## 例外情况（非常少）

只有以下情况可以不严格遵循TDD：
1. 用户明确说"不要写测试"（极少）
2. 纯UI更改（无逻辑）
3. 文档/注释更改
4. 配置文件修改

**对于所有C++代码实现，TDD是强制性的。**

## 自动化要求

Claude必须**主动、自动**地：
1. 调用 `/ue-build` skill（不等用户说"编译一下"）
2. 调用 `/ue-test` skill（不等用户说"测试一下"）
3. 分析结果并修复问题
4. 重复直到成功

**这不是可选的，这是标准工作流程。**

## 沟通模板

### 开始时（强制性声明）
```
"我将使用TDD方式实现：

测试计划：
1. [测试用例1]
2. [测试用例2]
3. [测试用例3]

现在开始编写测试..."
```

### 实现过程中（透明化）
```
"测试已编写，现在构建项目验证测试失败...
[自动调用 /ue-build]
[自动调用 /ue-test]
✅ 测试如预期失败（红阶段）

现在实现功能代码...
[编写代码]

自动构建项目...
[自动调用 /ue-build]
✅ 构建成功

自动运行测试...
[自动调用 /ue-test]
✅ 所有测试通过（绿阶段）

运行回归测试...
[自动调用 /ue-test 运行所有测试]
✅ 无回归问题"
```

### 完成时（包含证据）
```
"✅ 功能实现完成并验证

文件：
- 实现：Path/To/Implementation.cpp
- 测试：Path/To/Tests.cpp

测试结果：
✅ TestCase1 - 通过
✅ TestCase2 - 通过
✅ TestCase3 - 通过
✅ 回归测试 - 通过 (X个测试)

构建：3.2秒
测试：1.5秒"
```

## 为什么这是强制性的？

1. **质量保证** - 测试先行确保代码正确性
2. **防止回归** - 自动化测试防止未来破坏
3. **文档作用** - 测试是可执行的规格说明
4. **重构信心** - 有测试覆盖才能安全重构
5. **专业标准** - 这是现代软件工程的基本要求

## 违反后果

如果Claude跳过测试：
- ❌ 代码可能有bug但未发现
- ❌ 用户得到虚假的"完成"信号
- ❌ 未来可能引入回归问题
- ❌ 违反专业工程实践
- ❌ 失去用户信任

## 总结

**每次写C++代码 → 必须先写测试 → 必须自动构建 → 必须自动测试 → 所有测试通过才算完成**

这不是建议，这是**强制要求**。
